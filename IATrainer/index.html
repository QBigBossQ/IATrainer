<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Entrenador con IA (cámara + detección de pose)</title>

  <!-- ====== Librerías de IA (TensorFlow.js + pose-detection) ====== -->
  <!-- Cargar en este orden: core -> converter -> backend -> modelo de detección de pose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <style>
    :root{
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --muted: #94a3b8; /* slate-400 */
      --text: #e5e7eb; /* gray-200 */
      --primary: #22c55e; /* green-500 */
      --warn: #f59e0b; /* amber-500 */
      --danger:#ef4444; /* red-500 */
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(180deg,#0b1022,#0f172a 30%,#0f172a);
      color:var(--text); font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      min-height:100dvh; display:flex; flex-direction:column;
    }
    header{
      padding:18px 20px; border-bottom:1px solid #1f2937; display:flex; align-items:center; gap:14px; flex-wrap:wrap;
    }
    header h1{font-size:20px; margin:0; letter-spacing:.3px}
    .badge{font-size:12px; padding:4px 8px; border-radius:999px; background:#1f2937; color:var(--muted)}

    .container{display:grid; grid-template-columns: 380px 1fr; gap:18px; padding:18px; flex:1}
    @media (max-width: 980px){.container{grid-template-columns:1fr}}

    .panel{background:var(--panel); border:1px solid #1f2937; border-radius:16px; padding:16px}
    .panel h2{margin:0 0 12px 0; font-size:16px; color:#cbd5e1}

    .controls label{display:block; font-size:13px; color:var(--muted); margin-bottom:6px}
    .controls select,.controls input{
      width:100%; padding:10px 12px; background:#0b1220; color:var(--text);
      border:1px solid #1f2937; border-radius:12px; outline:none;
    }
    .row{display:grid; grid-template-columns:1fr 1fr; gap:12px}
    .row3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px}

    .btns{display:flex; gap:10px; margin-top:12px}
    .btn{appearance:none; border:1px solid #1f2937; background:#111827; color:#e5e7eb; padding:10px 14px; border-radius:14px; cursor:pointer}
    .btn.primary{background:var(--primary); border-color:#16a34a; color:#052e16; font-weight:600}
    .btn.stop{background:var(--danger); border-color:#b91c1c; color:#fff}
    .btn:disabled{opacity:.5; cursor:not-allowed}

    .stats{display:grid; grid-template-columns:repeat(3,1fr); gap:10px}
    .stat{background:#0b1220; border:1px solid #1f2937; border-radius:14px; padding:12px}
    .stat .label{font-size:12px; color:var(--muted)}
    .stat .value{font-size:22px; font-weight:700; margin-top:2px}

    .tips{font-size:13px; color:#cbd5e1; background:#0b1220; border:1px dashed #1f2937; border-radius:12px; padding:12px; line-height:1.35}

    /* Vista de cámara */
    .stage{position:relative; background:#000; border-radius:16px; overflow:hidden; height: min(70vh, 720px)}
    video{position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scaleX(-1);}
    canvas{position:absolute; inset:0; width:100%; height:100%; pointer-events:none;}

    .overlay{position:absolute; left:12px; bottom:12px; background:rgba(2,6,23,.6); backdrop-filter: blur(8px);
      border:1px solid #1f2937; border-radius:12px; padding:10px 12px; font-size:13px}
    .feedback{margin-top:8px; font-weight:600}
    .good{color:var(--primary)}
    .warn{color:var(--warn)}
    .bad{color:var(--danger)}

    footer{padding:14px 18px; color:var(--muted); font-size:12px; text-align:center; border-top:1px solid #1f2937}
    a{color:#93c5fd}
  </style>
</head>
<body>
  <header>
    <h1>Entrenador de ejercicios con IA (cámara)</h1>
    <span class="badge">MoveNet · TF.js · 100% en el navegador</span>
  </header>

  <div class="container">
    <!-- Panel lateral de control -->
    <aside class="panel">
      <h2>Configura tu sesión</h2>
      <div class="controls">
        <label for="exercise">Ejercicio</label>
        <select id="exercise">
          <option value="squats">Sentadillas</option>
          <option value="jacks">Jumping Jacks</option>
          <option value="lunges">Desplantes alternados</option>
          <option value="arm_raises">Elevaciones de brazos</option>
          <option value="high_knees">Rodillas altas</option>
        </select>

        <div class="row" style="margin-top:12px">
          <div>
            <label for="intensity">Intensidad</label>
            <select id="intensity">
              <option value="low">Baja</option>
              <option value="medium" selected>Media</option>
              <option value="high">Alta</option>
            </select>
          </div>
          <div>
            <label for="duration">Duración (minutos)</label>
            <input id="duration" type="number" min="1" max="60" value="5" />
          </div>
        </div>

        <div class="btns">
          <button id="start" class="btn primary">Iniciar</button>
          <button id="stop" class="btn stop" disabled>Detener</button>
        </div>
      </div>

      <div style="height:12px"></div>
      <div class="stats">
        <div class="stat">
          <div class="label">Tiempo restante</div>
          <div id="timeLeft" class="value">00:00</div>
        </div>
        <div class="stat">
          <div class="label">Repeticiones</div>
          <div id="reps" class="value">0</div>
        </div>
        <div class="stat">
          <div class="label">Ritmo (rep/min)</div>
          <div id="pace" class="value">0</div>
        </div>
      </div>

      <div style="height:12px"></div>
      <div class="tips">
        • Concede permiso a la cámara. <br/>
        • Coloca el cuerpo entero a la vista (cabeza a pies si es posible). <br/>
        • La detección ocurre <b>en tu navegador</b>; el video no sale de tu equipo.
      </div>
    </aside>

    <!-- Escenario de cámara + overlay -->
    <main class="panel">
      <h2>Vista</h2>
      <div class="stage">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="canvas"></canvas>
        <div class="overlay">
          <div><b>Estado:</b> <span id="status">Listo</span></div>
          <div class="feedback" id="feedback"></div>
        </div>
      </div>
    </main>
  </div>

  <footer>
    Hecho para GitHub Pages · Si ves el error "Invalid architecture Lightning" es porque se pasó una cadena incorrecta al modelo. Aquí usamos MoveNet con <code>SINGLEPOSE_LIGHTNING</code> (la forma correcta) para evitarlo.
  </footer>

  <script>
    // =============================================================
    // UTILIDADES GENERALES
    // =============================================================
    const $ = (sel) => document.querySelector(sel);
    const video = $('#video');
    const canvas = $('#canvas');
    const ctx = canvas.getContext('2d');

    const ui = {
      exercise: $('#exercise'),
      intensity: $('#intensity'),
      duration: $('#duration'),
      start: $('#start'),
      stop: $('#stop'),
      timeLeft: $('#timeLeft'),
      reps: $('#reps'),
      pace: $('#pace'),
      status: $('#status'),
      feedback: $('#feedback'),
    };

    const MIN_CONF = 0.35; // confianza mínima para usar un punto

    // Ajusta el canvas al tamaño del elemento video manteniendo la nitidez en pantallas HiDPI
    function resizeCanvasToDisplaySize() {
      const rect = video.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(1,0,0,1,0,0); // reset transform
      // Espejar el canvas para coincidir con el espejo del <video>
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
    }

    function lerp(a,b,t){ return a + (b-a)*t; }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

    function dist(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }

    // Ángulo (en grados) en el punto B formado por A-B-C
    function angleABC(A,B,C){
      if (!A || !B || !C) return NaN;
      const ab = {x: A.x - B.x, y: A.y - B.y};
      const cb = {x: C.x - B.x, y: C.y - B.y};
      const dot = (ab.x*cb.x + ab.y*cb.y);
      const magAB = Math.hypot(ab.x, ab.y);
      const magCB = Math.hypot(cb.x, cb.y);
      if (magAB === 0 || magCB === 0) return NaN;
      let cos = clamp(dot / (magAB*magCB), -1, 1);
      return Math.acos(cos) * 180 / Math.PI;
    }

    // Convierte un array de keypoints a un mapa por nombre (leftHip, rightKnee, etc.) normalizado a canvas px
    function keypointMapFromPose(pose){
      if (!pose || !pose.keypoints) return {};
      // La librería entrega coordenadas en px del video fuente; las escalamos al canvas actual.
      const sx = canvas.width / video.videoWidth;
      const sy = canvas.height / video.videoHeight;
      const map = {};
      for (const kp of pose.keypoints) {
        if (!kp || kp.score == null) continue;
        // Algunas builds usan kp.name, otras kp.part. Normalizamos a `name`.
        const name = kp.name || kp.part; 
        if (!name) continue;
        map[name] = { x: kp.x * sx, y: kp.y * sy, score: kp.score };
      }
      return map;
    }

    // Dibuja el esqueleto y los puntos clave
    function drawSkeleton(pose){
      if (!pose) return;
      const kps = pose.keypoints?.filter(k=> (k.score ?? 0) > MIN_CONF) || [];
      ctx.lineWidth = 4; ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';

      // Uniones adyacentes provistas por la utilidad del modelo
      const pairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
      for (const [i,j] of pairs){
        const a = pose.keypoints[i];
        const b = pose.keypoints[j];
        if ((a?.score ?? 0) > MIN_CONF && (b?.score ?? 0) > MIN_CONF){
          ctx.beginPath();
          ctx.moveTo(a.x * canvas.width / video.videoWidth, a.y * canvas.height / video.videoHeight);
          ctx.lineTo(b.x * canvas.width / video.videoWidth, b.y * canvas.height / video.videoHeight);
          ctx.stroke();
        }
      }
      for (const kp of kps){
        const x = kp.x * canvas.width / video.videoWidth;
        const y = kp.y * canvas.height / video.videoHeight;
        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
      }
    }

    // Texto con fondo para mejor legibilidad
    function drawLabel(text, x, y){
      ctx.font = '16px system-ui, sans-serif';
      ctx.textBaseline = 'top';
      const pad = 6;
      const m = ctx.measureText(text);
      ctx.fillStyle = 'rgba(2,6,23,0.65)';
      ctx.fillRect(x, y, m.width + pad*2, 24);
      ctx.fillStyle = '#e5e7eb';
      ctx.fillText(text, x + pad, y + 4);
    }

    // =============================================================
    // CONFIGURACIÓN DE INTENSIDAD (umbrales)
    // =============================================================
    const PROFILES = {
      low:   { downKnee: 105, upKnee: 160, downElbow: 100, upElbow: 160, minInterval: 450, jackFeetOpen: 1.4, jackFeetClose: 0.7, kneeLift: 0.35 },
      medium:{ downKnee: 95,  upKnee: 165, downElbow: 95,  upElbow: 165, minInterval: 500, jackFeetOpen: 1.6, jackFeetClose: 0.6, kneeLift: 0.40 },
      high:  { downKnee: 90,  upKnee: 170, downElbow: 90,  upElbow: 170, minInterval: 600, jackFeetOpen: 1.8, jackFeetClose: 0.55, kneeLift: 0.45 },
    };

    function getProfile(){
      return PROFILES[ui.intensity.value] || PROFILES.medium;
    }

    // =============================================================
    // LÓGICA DE CADA EJERCICIO (máquinas de estado simples)
    // =============================================================
    function makeExerciseSquats(){
      let stage = 'up'; // 'down' cuando flexiona; contamos al volver a 'up'
      let reps = 0; let lastCount = 0; let fb = '';
      return {
        name: 'Sentadillas',
        reset(){ stage='up'; reps=0; lastCount=0; fb=''; },
        update(pose, dt){
          const p = getProfile();
          const m = keypointMapFromPose(pose);
          const lk = m.leftKnee, rk = m.rightKnee, lh = m.leftHip, rh = m.rightHip, la = m.leftAnkle, ra = m.rightAnkle;
          if (!lk || !rk || !lh || !rh || !la || !ra) { fb='Asegura que se vean caderas y rodillas'; return reps; }
          const kneeL = angleABC(lh, lk, la);
          const kneeR = angleABC(rh, rk, ra);
          const knee = Math.min(kneeL, kneeR);
          const now = performance.now();
          if (stage==='up' && knee < p.downKnee){ stage='down'; fb='✔️ Baja controlado'; }
          else if (stage==='down' && knee > p.upKnee){
            if (now - lastCount > p.minInterval){ reps++; lastCount = now; fb='⬆️ Extiende caderas (1 rep)'; }
            stage='up';
          }
          // Feedback de profundidad
          if (stage==='down' && knee >= p.downKnee) fb='Baja un poco más';
          return reps;
        },
        feedback(){ return fb; },
      };
    }

    function makeExerciseJacks(){
      let phase = 'closed'; // closed -> open -> closed => 1 rep
      let reps=0, last=0, fb='';
      return {
        name:'Jumping Jacks',
        reset(){ phase='closed'; reps=0; last=0; fb=''; },
        update(pose){
          const p = getProfile();
          const m = keypointMapFromPose(pose);
          const ls=m.leftShoulder, rs=m.rightShoulder, lh=m.leftHip, rh=m.rightHip, la=m.leftAnkle, ra=m.rightAnkle, lw=m.leftWrist, rw=m.rightWrist, nose=m.nose;
          if(!ls||!rs||!lh||!rh||!la||!ra||!lw||!rw||!nose){ fb='Colócate de frente, cuerpo completo'; return reps; }
          const unit = dist(ls, rs) || 100; // escala basada en hombros
          const feet = dist(la, ra) / unit;
          const handsUp = (lw.y < nose.y) && (rw.y < nose.y);
          const handsDown = (lw.y > lh.y) && (rw.y > rh.y);
          const open = feet > p.jackFeetOpen && handsUp;
          const closed = feet < p.jackFeetClose && handsDown;
          const now=performance.now();
          if (phase==='closed' && open){ phase='open'; fb='✔️ Abre brazos/piernas'; }
          else if (phase==='open' && closed){ if(now-last>p.minInterval){ reps++; last=now; fb='⬇️ Cierra (1 rep)'; } phase='closed'; }
          if (phase==='closed' && !handsDown) fb='Baja brazos para cerrar';
          return reps;
        },
        feedback(){ return fb; },
      };
    }

    function makeExerciseLunges(){
      let stage='up', reps=0, last=0, fb='';
      return {
        name:'Desplantes alternados',
        reset(){ stage='up'; reps=0; last=0; fb=''; },
        update(pose){
          const p=getProfile();
          const m=keypointMapFromPose(pose);
          const lk=m.leftKnee, rk=m.rightKnee, lh=m.leftHip, rh=m.rightHip, la=m.leftAnkle, ra=m.rightAnkle;
          if(!lk||!rk||!lh||!rh||!la||!ra){ fb='Asegura que se vean caderas y rodillas'; return reps; }
          const kneeL=angleABC(lh, lk, la);
          const kneeR=angleABC(rh, rk, ra);
          const deep = Math.min(kneeL,kneeR) < (p.downKnee-5); // un poco más exigente que sentadilla
          const tall = (kneeL>p.upKnee && kneeR>p.upKnee);
          const now=performance.now();
          if(stage==='up' && deep){ stage='down'; fb='✔️ Baja con una pierna al frente'; }
          else if(stage==='down' && tall){ if(now-last>p.minInterval){ reps++; last=now; fb='⬆️ Vuelve al centro (1 rep)'; } stage='up'; }
          return reps;
        },
        feedback(){ return fb; },
      };
    }

    function makeExerciseArmRaises(){
      let phase='down', reps=0, last=0, fb='';
      return {
        name:'Elevaciones de brazos',
        reset(){ phase='down'; reps=0; last=0; fb=''; },
        update(pose){
          const p=getProfile();
          const m=keypointMapFromPose(pose);
          const lw=m.leftWrist, rw=m.rightWrist, ls=m.leftShoulder, rs=m.rightShoulder, nose=m.nose, lh=m.leftHip, rh=m.rightHip;
          if(!lw||!rw||!ls||!rs||!nose||!lh||!rh){ fb='Mantén hombros, muñecas y cabeza visibles'; return reps; }
          const up = lw.y < nose.y && rw.y < nose.y; // manos arriba de la cabeza
          const down = lw.y > lh.y && rw.y > rh.y;   // manos abajo a la altura de cadera
          const now=performance.now();
          if(phase==='down' && up){ phase='up'; fb='✔️ Sube brazos arriba'; }
          else if(phase==='up' && down){ if(now-last>p.minInterval){ reps++; last=now; fb='⬇️ Baja controlado (1 rep)'; } phase='down'; }
          if(phase==='down' && !down) fb='Baja las manos hasta cadera';
          return reps;
        },
        feedback(){ return fb; },
      };
    }

    function makeExerciseHighKnees(){
      let lastSide='none', baseY=0, reps=0, last=0, fb='';
      return {
        name:'Rodillas altas',
        reset(){ lastSide='none'; baseY=0; reps=0; last=0; fb=''; },
        update(pose){
          const p=getProfile();
          const m=keypointMapFromPose(pose);
          const lh=m.leftHip, rh=m.rightHip, lk=m.leftKnee, rk=m.rightKnee, ls=m.leftShoulder, rs=m.rightShoulder;
          if(!lh||!rh||!lk||!rk||!ls||!rs){ fb='Mantén a la vista hombros, caderas y rodillas'; return reps; }
          const unit = dist(ls, rs) || 100;
          const hipY = (lh.y+rh.y)/2; // referencia de altura de cadera
          const liftL = (lk.y < hipY - unit*getProfile().kneeLift);
          const liftR = (rk.y < hipY - unit*getProfile().kneeLift);
          const now=performance.now();
          if(liftL && lastSide!=='L' && now-last>p.minInterval){ reps++; last=now; lastSide='L'; fb='⬆️ Izquierda arriba (1)'; }
          else if(liftR && lastSide!=='R' && now-last>p.minInterval){ reps++; last=now; lastSide='R'; fb='⬆️ Derecha arriba (1)'; }
          return reps;
        },
        feedback(){ return fb; },
      };
    }

    const EXERCISES = {
      squats: makeExerciseSquats(),
      jacks: makeExerciseJacks(),
      lunges: makeExerciseLunges(),
      arm_raises: makeExerciseArmRaises(),
      high_knees: makeExerciseHighKnees(),
    };

    function currentExercise(){ return EXERCISES[ui.exercise.value]; }

    // =============================================================
    // CÁMARA + MODELO
    // =============================================================
    async function setupCamera(){
      // Preferimos la cámara trasera en móviles si existe
      const constraints = { video: { facingMode: 'user', width: {ideal:1280}, height: {ideal:720} }, audio:false };
      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        await new Promise(res => video.onloadedmetadata = res);
        video.play();
        return true;
      } catch (err){
        console.error('No se pudo acceder a la cámara', err);
        ui.status.textContent = 'Error: no se pudo acceder a la cámara';
        return false;
      }
    }

    let detector = null;
    async function loadModel(){
      // Aseguramos backend WebGL para buen rendimiento
      await tf.setBackend('webgl');
      await tf.ready();
      // MUY IMPORTANTE: usar la constante correcta para evitar "Invalid architecture Lightning"
      detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
      );
    }

    // =============================================================
    // BUCLE PRINCIPAL DE ENTRENAMIENTO
    // =============================================================
    let running = false; let rafId = null; let endAt = 0; let reps = 0; let repHistory = [];

    function formatTime(ms){
      ms = Math.max(0, ms);
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const ss = s%60;
      return `${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
    }

    function updateStatsUI(){
      const remaining = Math.max(0, endAt - performance.now());
      ui.timeLeft.textContent = formatTime(remaining);
      ui.reps.textContent = String(reps);
      // ritmo promedio últimas 10s
      const horizon = performance.now() - 10_000;
      repHistory = repHistory.filter(t => t >= horizon);
      const pace = repHistory.length * 6; // reps/10s * 60
      ui.pace.textContent = String(pace);
    }

    async function renderLoop(){
      if (!running) return;
      resizeCanvasToDisplaySize();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Estima pose
      let poses = [];
      try {
        poses = await detector.estimatePoses(video, { maxPoses: 1, flipHorizontal: false });
      } catch(err){ console.error(err); }

      const pose = poses[0];
      drawSkeleton(pose);

      if (pose){
        const prev = reps;
        reps = currentExercise().update(pose) || reps;
        if (reps > prev){ repHistory.push(performance.now()); }
      }

      drawLabel(currentExercise().name + ' · ' + ui.intensity.options[ui.intensity.selectedIndex].text, 12, 12);

      ui.feedback.textContent = currentExercise().feedback() || '';
      ui.feedback.className = 'feedback ' + (reps>0 ? 'good' : '');

      updateStatsUI();

      if (performance.now() >= endAt){ stopWorkout(); return; }
      rafId = requestAnimationFrame(renderLoop);
    }

    function startWorkout(){
      if (!detector || !video.srcObject){ ui.status.textContent='Cargando modelo/cámara...'; return; }
      running = true; reps = 0; repHistory.length = 0; currentExercise().reset();
      const mins = Math.max(1, parseInt(ui.duration.value || '5', 10));
      endAt = performance.now() + mins*60*1000;
      ui.start.disabled = true; ui.stop.disabled = false;
      ui.exercise.disabled = true; ui.intensity.disabled = true; ui.duration.disabled = true;
      ui.status.textContent = 'Sesión en progreso';
      renderLoop();
    }

    function stopWorkout(){
      running = false; if (rafId) cancelAnimationFrame(rafId);
      ui.start.disabled = false; ui.stop.disabled = true;
      ui.exercise.disabled = false; ui.intensity.disabled = false; ui.duration.disabled = false;
      ui.status.textContent = 'Detenido';
    }

    ui.start.addEventListener('click', startWorkout);
    ui.stop.addEventListener('click', stopWorkout);

    // Inicializar todo
    (async function init(){
      ui.status.textContent = 'Inicializando...';
      const camOk = await setupCamera();
      if (!camOk) return;
      resizeCanvasToDisplaySize();
      await loadModel();
      ui.status.textContent = 'Listo: selecciona y presiona Iniciar';
    })();
  </script>
</body>
</html>
